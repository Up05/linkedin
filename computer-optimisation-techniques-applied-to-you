# Computer Optimisation Techniques Applied to You! Yes, You!

## Caching

Caching, e.g.: bringing your coffee to your desk, so you don't have to go to the kitchen for every sip. We do it all the time, computers do it all the time. ([Well, except for JavaScript](https://www.kaspersky.com/blog/apple-cpu-encryption-vulnerability/50869/)) It is an amazing way to make the slow parts, basically, faster. Now, the obvious analogy here is short-term memory. After submitting a geography test, it is common courtesy to completely clear out system cache and forget fish rates. However I would also argue, that muscle memory is caching too. And, while short-term memory is cool (I couldn't make anything complex without it), muscle memory is an absolute game changing, overpowered life hack _that we are all just used to_.
Now, while computer cache is mainly "spatial" and "temporal", i.e.: based on space and time, we seem to, still like familiar things, but introduce our own rating for what should stay in the cache. This is mainly based on repetition count, but also, seemingly, random chance as well as how important we hold it and our general state at each repetition. So, our muscle memory works not only like memory, but also like muscle... 

Linked lists are terrible for caching

looping over columns vs rows

## Branching

Branches occur whenever the computer has to make a decision. For example, an if statement creates 1 extra branch, an if-else creates 2 extra branches and so on. Now, this is almost unnoticable when you have, for example, a for loop: `for(int i = 0; i < 1000000; i ++);`. Like, if compiler optimisations off, there's a million branches there! And it's still just fine because of the Branch Predictor. Which (well I don't know what it does, they won't tell me :<), generally, takes into account the ammount of times this branch was taken in the past and tries to predict whether the branch will be taken this time around too. So, I imagine, it will correctly predict the future 999999 to 999998 times and fail once or twice.

Now then, let me tell you why I use Vim. Most Microsoft Word enjoyers, would say: "click the backwards *P* there", but that's only the very last step, right? Unless you already have your cursor on the pilcrow, you first: have to locate the backwards *P*, then you have to move your cursor near the backwards *P*, check if you are on the backwards *P*, move your cursor slightly towards the backwards *P*, then check again, and move again, and only after all that you click the button. Now then, how many of those branches were there? Well, you first have to scan for what most closely resembles a backwards *P*, but, since that is very predictable let's count it as a single, after the target has been aquired. Moving the cursor and checking whether it is time to click, will, likely, result in up to 5 very unpredictable branches. So, there are not many branches here, but it adds up, since every single button works this same way. In Vim, well it's fiddly to display non-printable characters, so instead, if you decided to change your perentheses to commas, well you press `%` to go to the opening perentheses from inside, then do a quick little `r,` to replace the `(` with a `,`, then `f)` and then the replace again (a.k.a: `.`). No decisions, only problem solving the first time and, perhaps, remembering (fetching from cache) you actions in the future.

What I wanted to highlight with this comparison is that micro decisions are slow and tiresome. Instead, leave it to your muscle memory, which, by the way, has a builtin branch predictor (if you ever drove back home from work by pure instinct).  

## Multithreading

People are terrible at doing multiple things at once, but so are computer.   


## Batching & compression
